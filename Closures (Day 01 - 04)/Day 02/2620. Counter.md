# Day 02 Problems: Closures - Counter Function (LeetCode 2620)

## 🔰 Problem Description

Write a function `createCounter` that accepts an integer `n` and returns a **counter function**.

The returned function should return the current count when called, and then increment the count by `1` each time it is called again.

---

## 📘 Explanation (in Bangla)

১. **createCounter ফাংশনটি কি করে?**  
এই ফাংশন একটি সংখ্যা `n` ইনপুট হিসেবে নেয় এবং এমন একটি নতুন ফাংশন রিটার্ন করে, যেটি প্রতিবার কল করলে `n`, `n+1`, `n+2`, ... এভাবে বাড়তে থাকে।

২. **const counter = createCounter(10);**  
এখানে তুমি `10` দিয়ে কাউন্টার শুরু করছো। এখন `counter()` কল করলে প্রথমবার `10` রিটার্ন করবে, এরপর `11`, তারপর `12`, এভাবে চলবে।

৩. **Closure এর ব্যবহার:**  
এই সমস্যাটিতে JavaScript এর **closure** ব্যবহার করা হয়েছে। কারণ, রিটার্নকৃত ফাংশনটি বাইরের `n` ভ্যারিয়েবলটি মনে রাখে এবং প্রতিবার কল করলে তা ১ করে বাড়িয়ে দেয়।

---

## 🧪 Examples

### Example 1

Input: 
n = 10 
["call","call","call"]
Output: [10,11,12]
Explanation: 
counter() = 10 // The first time counter() is called, it returns n.
counter() = 11 // Returns 1 more than the previous time.
counter() = 12 // Returns 1 more than the previous time.

### Example 1

Input: 
n = -2
["call","call","call","call","call"]
Output: [-2,-1,0,1,2]
Explanation: counter() initially returns -2. Then increases after each sebsequent call.


**Input:**
```js
const counter = createCounter(10);
```

## ✅ Solution
```js
    var createCounter = function(n) {
        return function() {
            return n++;
        };
    };

    const counter = createCounter(10);

    console.log(counter()); // 10
    console.log(counter()); // 11
    console.log(counter()); // 12

```

# ✅ These cover all major JavaScript styles:

- Classic closure
- Arrow function closure
- Class-based
- Object-based
- Generator-based
- IIFE-based

## 1. Closure with Function Expression
```js
function createCounter(n) {
    return function() {
        return n++;
    };
}

const counter1 = createCounter(10);
console.log(counter1()); // 10
console.log(counter1()); // 11
console.log(counter1()); // 12
```

## 2. Closure with Arrow Function
```js
const createCounter = (n) => () => n++;

const counter2 = createCounter(-2);
console.log(counter2()); // -2
console.log(counter2()); // -1
console.log(counter2()); // 0

```

## 3. Using ES6 Class
```js
class Counter {
    constructor(n) {
        this.value = n;
    }

    call() {
        return this.value++;
    }
}

const counter3 = new Counter(5);
console.log(counter3.call()); // 5
console.log(counter3.call()); // 6
console.log(counter3.call()); // 7

```

## 4. Using Object with Method
```js
    function createCounter(n) {
    return {
        call: function() {
            return n++;
        }
    };
}

const counter4 = createCounter(100);
console.log(counter4.call()); // 100
console.log(counter4.call()); // 101
console.log(counter4.call()); // 102

```


## 5. Using Generator Function
```js
function* createCounter(n) {
    while (true) {
        yield n++;
    }
}

const counter5 = createCounter(0);
console.log(counter5.next().value); // 0
console.log(counter5.next().value); // 1
console.log(counter5.next().value); // 2
```

## 6. Using Immediately Invoked Function Expression (IIFE)
```js
const createCounter = (n) => {
    return (function() {
        return function() {
            return n++;
        };
    })();
};

const counter6 = createCounter(3);
console.log(counter6()); // 3
console.log(counter6()); // 4
console.log(counter6()); // 5

```


