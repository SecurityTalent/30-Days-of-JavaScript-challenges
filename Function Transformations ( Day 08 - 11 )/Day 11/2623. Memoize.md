# 📝 JavaScript Memoize (Problem 2623)

Memoization হলো এক ধরনের অপ্টিমাইজেশন টেকনিক।  
একটি ফাংশন একই ইনপুট দিয়ে বারবার চালানো হলে, সেটাকে বারবার হিসাব না করে, আগের সংরক্ষিত (cached) ফলাফলটাই ফেরত দেওয়া হয়।  
এটি বিশেষ করে স্লো বা রিকারসিভ ফাংশন (যেমন Fibonacci বা Factorial) এর জন্য খুবই উপকারী।

---

## 🚀 Memoize কিভাবে কাজ করে
1. একটি ফাংশন নিন (যেমন `fib(n)`).
2. একটি **cache** তৈরি করুন যেখানে ফলাফল সংরক্ষণ করবেন।
3. ফাংশনটি চালানোর সময়:
   - আর্গুমেন্টগুলোকে একটি **key** তে রূপান্তর করা হয়।
   - key যদি cache-এ থাকে, সরাসরি সেই ফলাফল রিটার্ন হয়।
   - না থাকলে আসল ফাংশন চালিয়ে ফলাফল বের করে cache-এ সংরক্ষণ করে, তারপর রিটার্ন হয়।

---

## 🔹 সমস্যা কী?

তুমি একটা ফাংশন পাবে (যেটা sum, fib বা factorial হতে পারে)
তুমি এমন একটা memoized version বানাবে –
মানে একই ইনপুট দিয়ে দুবার কল করলে আসল ফাংশন আর কল হবে না, বরং আগে থেকে cache করা মানটা ফিরিয়ে দেবে।

অর্থাৎ –
- প্রথমবার নতুন ইনপুট এলে ফাংশন চালাবে (value বের করবে)
- পরেরবার ওই একই ইনপুট এলে ফাংশন আর চালাবে না, আগে যেটা cache করে রেখেছিল সেটা দিবে

আর সাথে সাথে একটা call count রাখতে হবে – ফাংশনটা মোট কতবার আসলেই চালানো হয়েছে সেটা বের করতে।

## 🔹 দেওয়া তিনটা ফাংশন:
- sum(a,b) → দুইটা সংখ্যা যোগ করে
- fib(n) → Fibonacci series এর n-th সংখ্যা
- factorial(n) → n এর factorial বের করে

## 🔹 শর্ত:
- যদি আগে (2,3) দিয়ে sum চালাও আর পরে (3,2) দিয়ে চালাও – এটা আলাদা ধরা হবে।
(মানে (a,b) আর (b,a) এক জিনিস না।)
- factorial আর fib একটিমাত্র প্যারামিটার নেয়।

## 🔹 কাজের ধরন
- একটি **cache object** বানাতে হবে যেখানে key হবে arguments (যেমন `"2,2"` বা `"3"`)।
- **প্রথমবার কোনো input এলে**:
  - আসল ফাংশন চালাবে
  - ফলাফল cache-এ রাখবে
  - call count বাড়াবে
- **পরেরবার একই input এলে**:
  - cache থেকে value রিটার্ন করবে
  - call count আর বাড়াবে না



## 🔹 JavaScript কোড (memoize ফাংশন)
```js
function memoize(fn) {
  const cache = new Map();
  let callCount = 0;

  const memoized = function(...args) {
    const key = args.join(','); // args কে string বানালাম
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args); // আসল ফাংশন চালানো হচ্ছে
    cache.set(key, result);
    callCount++;
    return result;
  };

  // call count বের করার জন্য ফাংশন
  memoized.getCallCount = () => callCount;

  return memoized;
}
```

## 🔹 উদাহরণ ১ (sum)
```js
const sum = (a,b) => a + b;
const memoSum = memoize(sum);

console.log(memoSum(2,2)); // 4 (নতুন input → ফাংশন চালানো হয়েছে)
console.log(memoSum(2,2)); // 4 (আগের input → cache থেকে নিলো)
console.log(memoSum.getCallCount()); // 1

console.log(memoSum(1,2)); // 3 (নতুন input → চালানো হলো)
console.log(memoSum.getCallCount()); // 2
```

## 🔹 উদাহরণ ২ (factorial)
```js
const factorial = (n) => n <= 1 ? 1 : n * factorial(n-1);
const memoFactorial = memoize(factorial);

console.log(memoFactorial(2)); // 2 (নতুন)
console.log(memoFactorial(3)); // 6 (নতুন)
console.log(memoFactorial(2)); // 2 (cache থেকে)
console.log(memoFactorial.getCallCount()); // 2
console.log(memoFactorial(3)); // 6 (cache থেকে)
console.log(memoFactorial.getCallCount()); // 2
```

## 🔹 উদাহরণ ৩ (fib)
```js
const fib = (n) => n <= 1 ? 1 : fib(n-1) + fib(n-2);
const memoFib = memoize(fib);

console.log(memoFib(5)); // 8
console.log(memoFib.getCallCount()); // 1
```

## 🔹 সারসংক্ষেপ (বাংলায়):
- প্রথমবার কোনো ইনপুট দিলে আসল ফাংশন চালাবে
- পরেরবার একই ইনপুট দিলে cache থেকে answer দিবে
- আলাদা ইনপুট মানে আলাদা cache key
- মোট কতবার আসল ফাংশন চালানো হয়েছে সেটা getCallCount() দিয়ে জানা যাবে












