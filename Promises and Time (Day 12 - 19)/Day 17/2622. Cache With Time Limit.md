# 🗄️ 2622. Cache With Time Limit (টাইম লিমিট সহ ক্যাশ)

## 🧠 সমস্যা বিবরণ

তোমাকে একটি ক্লাস তৈরি করতে বলা হয়েছে যা **key-value pair** সংরক্ষণ করবে,  
কিন্তু প্রতিটি key এর জন্য একটি **expiry time** থাকবে।

ক্লাসটিতে তিনটি পাবলিক মেথড থাকবে:

1. **set(key, value, duration)**

   - key (integer), value (integer) এবং duration (মিলিসেকেন্ডে) নেয়।
   - যদি key ইতিমধ্যেই অমেয়াদী (un-expired) থাকে, তাহলে value এবং duration আপডেট করা হবে এবং **true** রিটার্ন করবে।
   - যদি key নতুন হয় বা expired হয়, তাহলে **false** রিটার্ন করবে।

2. **get(key)**

   - যদি key অমেয়াদী থাকে, value রিটার্ন করবে।
   - যদি key expired হয় বা নেই, **-1** রিটার্ন করবে।

3. **count()**
   - বর্তমান অমেয়াদী key এর সংখ্যা রিটার্ন করবে।

---

## ⚙️ Class Signature

```js
class TimeLimitedCache {
  constructor() {
    this.cache = new Map();
  }

  set(key, value, duration) {
    const now = Date.now();
    let existed = this.cache.has(key) && this.cache.get(key).expiry > now;

    if (this.cache.has(key)) clearTimeout(this.cache.get(key).timer);

    const timer = setTimeout(() => {
      this.cache.delete(key);
    }, duration);

    this.cache.set(key, {
      value: value,
      expiry: now + duration,
      timer: timer,
    });

    return existed;
  }

  get(key) {
    const now = Date.now();
    if (!this.cache.has(key)) return -1;
    const entry = this.cache.get(key);
    if (entry.expiry <= now) {
      this.cache.delete(key);
      return -1;
    }
    return entry.value;
  }

  count() {
    const now = Date.now();
    let cnt = 0;
    for (const [key, entry] of this.cache) {
      if (entry.expiry > now) cnt++;
      else this.cache.delete(key);
    }
    return cnt;
  }
}
```

## Example

```js
Example 1:

Input:
actions = ["TimeLimitedCache", "set", "get", "count", "get"]
values = [[], [1, 42, 100], [1], [], [1]]
timeDelays = [0, 0, 50, 50, 150]
Output: [null, false, 42, 1, -1]
Explanation:
At t=0, the cache is constructed.
At t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned.
At t=50, key=1 is requested and the value of 42 is returned.
At t=50, count() is called and there is one active key in the cache.
At t=100, key=1 expires.
At t=150, get(1) is called but -1 is returned because the cache is empty.
Example 2:

Input:
actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
timeDelays = [0, 0, 40, 50, 120, 200, 250]
Output: [null, false, true, 50, 50, -1, 0]
Explanation:
At t=0, the cache is constructed.
At t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned.
At t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten.
At t=50, get(1) is called which returned 50.
At t=120, get(1) is called which returned 50.
At t=140, key=1 expires.
At t=200, get(1) is called but the cache is empty so -1 is returned.
At t=250, count() returns 0 because the cache is empty.
```

## 🧠 মূল ধারণা

| ধারণা                | ব্যাখ্যা                                            |
| -------------------- | --------------------------------------------------- |
| `setTimeout()`       | নির্দিষ্ট সময় পরে key auto-delete হয়                |
| `clearTimeout()`     | পূর্বের টাইমার বাতিল করে, নতুন duration set করা হয়  |
| `Map()`              | key-value এবং expiry time সংরক্ষণের জন্য ব্যবহৃত হয় |
| `Time-Limited Cache` | নির্দিষ্ট সময় পর key অমেয়াদী হয়                    |

## 🧰 ব্যবহার উদাহরণ

```js
/**************************45ms😎**************************/
class TimeLimitedCache {
  constructor() {
    this.cache = new Map();
  }
  set(e, t, c) {
    const h = Date.now(),
      s = this.cache.has(e) && this.cache.get(e).expiry > h;
    return (
      this.cache.set(e, { value: t, expiry: h + c }),
      setTimeout(() => {
        this.cache.has(e) &&
          this.cache.get(e).expiry <= Date.now() &&
          this.cache.delete(e);
      }, c),
      s
    );
  }
  get(e) {
    const t = Date.now(),
      c = this.cache.get(e);
    return c && c.expiry > t ? c.value : (this.cache.delete(e), -1);
  }
  count() {
    const e = Date.now();
    let t = 0;
    for (const [c, h] of this.cache) h.expiry > e ? t++ : this.cache.delete(c);
    return t;
  }
}
```
