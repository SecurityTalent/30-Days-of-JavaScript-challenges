# ðŸ—„ï¸ 2622. Cache With Time Limit (à¦Ÿà¦¾à¦‡à¦® à¦²à¦¿à¦®à¦¿à¦Ÿ à¦¸à¦¹ à¦•à§à¦¯à¦¾à¦¶)

## ðŸ§  à¦¸à¦®à¦¸à§à¦¯à¦¾ à¦¬à¦¿à¦¬à¦°à¦£

à¦¤à§‹à¦®à¦¾à¦•à§‡ à¦à¦•à¦Ÿà¦¿ à¦•à§à¦²à¦¾à¦¸ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¤à§‡ à¦¬à¦²à¦¾ à¦¹à¦¯à¦¼à§‡à¦›à§‡ à¦¯à¦¾ **key-value pair** à¦¸à¦‚à¦°à¦•à§à¦·à¦£ à¦•à¦°à¦¬à§‡,  
à¦•à¦¿à¦¨à§à¦¤à§ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ key à¦à¦° à¦œà¦¨à§à¦¯ à¦à¦•à¦Ÿà¦¿ **expiry time** à¦¥à¦¾à¦•à¦¬à§‡à¥¤

à¦•à§à¦²à¦¾à¦¸à¦Ÿà¦¿à¦¤à§‡ à¦¤à¦¿à¦¨à¦Ÿà¦¿ à¦ªà¦¾à¦¬à¦²à¦¿à¦• à¦®à§‡à¦¥à¦¡ à¦¥à¦¾à¦•à¦¬à§‡:

1. **set(key, value, duration)**

   - key (integer), value (integer) à¦à¦¬à¦‚ duration (à¦®à¦¿à¦²à¦¿à¦¸à§‡à¦•à§‡à¦¨à§à¦¡à§‡) à¦¨à§‡à¦¯à¦¼à¥¤
   - à¦¯à¦¦à¦¿ key à¦‡à¦¤à¦¿à¦®à¦§à§à¦¯à§‡à¦‡ à¦…à¦®à§‡à¦¯à¦¼à¦¾à¦¦à§€ (un-expired) à¦¥à¦¾à¦•à§‡, à¦¤à¦¾à¦¹à¦²à§‡ value à¦à¦¬à¦‚ duration à¦†à¦ªà¦¡à§‡à¦Ÿ à¦•à¦°à¦¾ à¦¹à¦¬à§‡ à¦à¦¬à¦‚ **true** à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à¦¬à§‡à¥¤
   - à¦¯à¦¦à¦¿ key à¦¨à¦¤à§à¦¨ à¦¹à¦¯à¦¼ à¦¬à¦¾ expired à¦¹à¦¯à¦¼, à¦¤à¦¾à¦¹à¦²à§‡ **false** à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à¦¬à§‡à¥¤

2. **get(key)**

   - à¦¯à¦¦à¦¿ key à¦…à¦®à§‡à¦¯à¦¼à¦¾à¦¦à§€ à¦¥à¦¾à¦•à§‡, value à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à¦¬à§‡à¥¤
   - à¦¯à¦¦à¦¿ key expired à¦¹à¦¯à¦¼ à¦¬à¦¾ à¦¨à§‡à¦‡, **-1** à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à¦¬à§‡à¥¤

3. **count()**
   - à¦¬à¦°à§à¦¤à¦®à¦¾à¦¨ à¦…à¦®à§‡à¦¯à¦¼à¦¾à¦¦à§€ key à¦à¦° à¦¸à¦‚à¦–à§à¦¯à¦¾ à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à¦¬à§‡à¥¤

---

## âš™ï¸ Class Signature

```js
class TimeLimitedCache {
  constructor() {
    this.cache = new Map();
  }

  set(key, value, duration) {
    const now = Date.now();
    let existed = this.cache.has(key) && this.cache.get(key).expiry > now;

    if (this.cache.has(key)) clearTimeout(this.cache.get(key).timer);

    const timer = setTimeout(() => {
      this.cache.delete(key);
    }, duration);

    this.cache.set(key, {
      value: value,
      expiry: now + duration,
      timer: timer,
    });

    return existed;
  }

  get(key) {
    const now = Date.now();
    if (!this.cache.has(key)) return -1;
    const entry = this.cache.get(key);
    if (entry.expiry <= now) {
      this.cache.delete(key);
      return -1;
    }
    return entry.value;
  }

  count() {
    const now = Date.now();
    let cnt = 0;
    for (const [key, entry] of this.cache) {
      if (entry.expiry > now) cnt++;
      else this.cache.delete(key);
    }
    return cnt;
  }
}
```

## Example

```js
Example 1:

Input:
actions = ["TimeLimitedCache", "set", "get", "count", "get"]
values = [[], [1, 42, 100], [1], [], [1]]
timeDelays = [0, 0, 50, 50, 150]
Output: [null, false, 42, 1, -1]
Explanation:
At t=0, the cache is constructed.
At t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned.
At t=50, key=1 is requested and the value of 42 is returned.
At t=50, count() is called and there is one active key in the cache.
At t=100, key=1 expires.
At t=150, get(1) is called but -1 is returned because the cache is empty.
Example 2:

Input:
actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
timeDelays = [0, 0, 40, 50, 120, 200, 250]
Output: [null, false, true, 50, 50, -1, 0]
Explanation:
At t=0, the cache is constructed.
At t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned.
At t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten.
At t=50, get(1) is called which returned 50.
At t=120, get(1) is called which returned 50.
At t=140, key=1 expires.
At t=200, get(1) is called but the cache is empty so -1 is returned.
At t=250, count() returns 0 because the cache is empty.
```

## ðŸ§  à¦®à§‚à¦² à¦§à¦¾à¦°à¦£à¦¾

| à¦§à¦¾à¦°à¦£à¦¾                | à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾                                            |
| -------------------- | --------------------------------------------------- |
| `setTimeout()`       | à¦¨à¦¿à¦°à§à¦¦à¦¿à¦·à§à¦Ÿ à¦¸à¦®à§Ÿ à¦ªà¦°à§‡ key auto-delete à¦¹à§Ÿ                |
| `clearTimeout()`     | à¦ªà§‚à¦°à§à¦¬à§‡à¦° à¦Ÿà¦¾à¦‡à¦®à¦¾à¦° à¦¬à¦¾à¦¤à¦¿à¦² à¦•à¦°à§‡, à¦¨à¦¤à§à¦¨ duration set à¦•à¦°à¦¾ à¦¹à§Ÿ  |
| `Map()`              | key-value à¦à¦¬à¦‚ expiry time à¦¸à¦‚à¦°à¦•à§à¦·à¦£à§‡à¦° à¦œà¦¨à§à¦¯ à¦¬à§à¦¯à¦¬à¦¹à§ƒà¦¤ à¦¹à§Ÿ |
| `Time-Limited Cache` | à¦¨à¦¿à¦°à§à¦¦à¦¿à¦·à§à¦Ÿ à¦¸à¦®à§Ÿ à¦ªà¦° key à¦…à¦®à§‡à¦¯à¦¼à¦¾à¦¦à§€ à¦¹à§Ÿ                    |

## ðŸ§° à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦‰à¦¦à¦¾à¦¹à¦°à¦£

```js
/**************************45msðŸ˜Ž**************************/
class TimeLimitedCache {
  constructor() {
    this.cache = new Map();
  }
  set(e, t, c) {
    const h = Date.now(),
      s = this.cache.has(e) && this.cache.get(e).expiry > h;
    return (
      this.cache.set(e, { value: t, expiry: h + c }),
      setTimeout(() => {
        this.cache.has(e) &&
          this.cache.get(e).expiry <= Date.now() &&
          this.cache.delete(e);
      }, c),
      s
    );
  }
  get(e) {
    const t = Date.now(),
      c = this.cache.get(e);
    return c && c.expiry > t ? c.value : (this.cache.delete(e), -1);
  }
  count() {
    const e = Date.now();
    let t = 0;
    for (const [c, h] of this.cache) h.expiry > e ? t++ : this.cache.delete(c);
    return t;
  }
}
```
